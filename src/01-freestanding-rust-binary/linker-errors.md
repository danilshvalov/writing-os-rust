# Ошибки компоновщика

Компоновщик - это программа, которая упаковывает сгенерированный код в исполняемый файл. Поскольку формат исполняемый файлов в Linux, Windows и macOS различный, в каждой ОС есть собственный компоновщик. Так как компоновщики разные, то и сообщения об ошибке будут отличаться. Но причина ошибок одинаковая: конфигурация компоновщика по умолчанию предполагает, что наша программа зависит от среды выполнения Си, хотя это не так.

Для устранения ошибки мы должны сообщить компоновщику, что он не должен подключать среду исполнения Си. Мы можем сделать это передав определенный набор аргументов компоновщику или скомпилировать наш файл для железа без ОС.

## Компиляция для железа без ОС

По умолчанию Rust пытается создать исполняемый файл, который можно запустить на текущей системе. Например, если вы используете Windows на архитектуре `x86_64`, то Rust пытается создать `.exe` файл, который использует `x86_64` инструкции. Текущую операционную систему также называют `host system`.

Для описания различных сред исполнения Rust использует строку называемую [_target triple_]. Вы можете увидеть `target triple` для вашей системы с помощью команды `rustc --version --verbose`:

[_target triple_]: https://clang.llvm.org/docs/CrossCompilation.html#target-triple

```console
rustc 1.35.0-nightly (474e7a648 2019-04-07)
binary: rustc
commit-hash: 474e7a6486758ea6fc761893b1a49cd9076fb0ab
commit-date: 2019-04-07
host: x86_64-unknown-linux-gnu
release: 1.35.0-nightly
LLVM version: 8.0
```

Приведенный выше вывод получен из `x86_64` Linux системы. Мы видим, что `host` система - это `x86_64-unknown-linux-gnu`. Это означает, что система использует `x86_64` архитектуру, поставщиком ОС является  `unknown`, операционная система - `linux`, а [ABI] - (`gnu`).

При компиляции для нашей основной среды, компилятор Rust и компоновщик предполагали, что существует базовая операционная система, такая как Linux или Windows, использующая среду выполнения Си по умолчанию, что привело к ошибкам компоновщика. Чтобы избежать ошибки компоновщика, мы скомпилируем исполняемый файл для другой среды, которая не требует базовой ОС.

Примером таковой является среда "голого железа", именуемая как `thumbv7em-none-eabihf`, которая описывает [встроенную] [ARM] систему. Детали нам не важны, самое главное только то, что target triple не имеет базовой ОС, на что указывает `none` в названии target triple. Чтобы иметь возможность компилировать для этого target, мы также должны добавить его в rustup:

```console
$ rustup target add thumbv7em-none-eabihf
```

Эта команда загрузит копию стандартной библиотеки и ядро языка для системы. Теперь мы можем создать наш автономный исполняемый файл для этого target'a;

```console
$ cargo build --target thumbv7em-none-eabihf
```

Используя аргумент `--target` мы [кросс компилируем][cross compiler] наш исполняемый файл для bare metal target system. Поскольку target system не имеет операционной системы, компоновщик не пытается подключить среду выполнения Си и создание нашего исполняемого файла происходит успешно без ошибок компоновщика.

[cross compiler]: https://en.wikipedia.org/wiki/Cross_compiler
[embedded]: https://en.wikipedia.org/wiki/Embedded_system
[ABI]: https://en.wikipedia.org/wiki/Application_binary_interface
[ARM]: https://en.wikipedia.org/wiki/ARM_architecture
