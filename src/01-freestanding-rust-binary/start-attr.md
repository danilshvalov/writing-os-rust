## Аттрибут `start`

Можно подумать, что функция `main` - это первая функция, которая будет вызвана при запуске вашей программы. Однако у большинства языков программирования есть [среда выполнения][runtime system], которая отвечает за такие вещи, как сборка мусора (например в Java) или программные потоки (например goroutines в Go). Именно она то и вызывает функцию `main`.

[runtime system]: https://en.wikipedia.org/wiki/Runtime_system

В обычном бинарном файле Rust, который подключает стандартную библиотеку, выполнение начинается в runtime-библиотеке языка Си под названием `crt0` (
C runtime zero), которая устанавливает среду для Си-приложения. Это включает в себя создание стека и размещение аргументов в правильных регистрах. Затем среда выполнения Си вызывает [точку входа среды выполнения Rust][rt::lang_start], которая помечена языковым элементом `start`. Rust имеет очень маленькую среду выполнения, которая заботится о некоторых мелочах, таких как настройка защиты от переполнения стека или печать backtrace при панике. Затем среда выполнения вызывает функцию `main`.

[rt::lang_start]: https://github.com/rust-lang/rust/blob/bb4d1491466d8239a7a5fd68bd605e3276e97afb/src/libstd/rt.rs#L32-L73

Наш автономный исполняемый файл не имеет доступа к среде выполнения Rust и к `crt0`, поэтому нам нужно определить нашу собственную точку входа. Реализация языкового элемента `start` не решит нашу проблему, так как для работы потребуется `crt0`. Вместо этого нам нужно напрямую перезаписать точку входа `crt0`.

### Перезаписывание точки входа

Чтобы сообщить компилятору Rust, что мы не хотим использовать обычную цепочку точек входа, мы должны использовать `#![no_main]` атрибут.

```rust
#![no_std]
#![no_main]

use core::panic::PanicInfo;

/// Эта функция вызывается при панике
#[panic_handler]
fn panic(_info: &PanicInfo) -> ! {
    loop {}
}
```

Вы можете заметить, что мы удалили функцию `main`. Дело в том, что функция `main` не имеет смысла без среды выполнения, которая её вызывает. Вместо этого теперь мы перезаписываем точку входа в операционную систему с помощью функции `_start`:

```rust
#[no_mangle]
pub extern "C" fn _start() -> ! {
    loop {}
}
```

Используя атрибут `#[no_mangle]`, мы отключаем [искажение имен] (name mangling), чтобы гарантировать, что компилятор Rust создаст функцию с именем `_start`. Без этого атрибута компилятор сгенерирует какой-нибудь загадочный символ, наподобие `_ZN3blog_os4_start7hb173fedf945531caE`, чтобы дать каждой функции уникальное имя. Атрибут является обязательным, поскольку на следующем шаге нам нужно сообщить имя функции точки входа компоновщику.

Мы также должны пометить функцию как `extern "C"`, чтобы сообщить компилятору, что он должен использовать [соглашение о вызове языка Си] (C calling convention) для этой функции (вместо неопределенного соглашения о вызове языка Rust). Причина, по которой мы назвали точку входа именем `_start`, заключается в том, что это имя точки входа по умолчанию для большинства систем.

[искажение имен]: https://en.wikipedia.org/wiki/Name_mangling
[Cсоглашение о вызове языка Си]: https://en.wikipedia.org/wiki/Calling_convention

Возвращаемый тип `!` говорит о том, что функция помечена как расходящаяся (diverging), то есть никогда не возвращает результат. Это необходимо, потому что точка входа не вызывается какой-либо функцией, но вызывается непосредственно операционной системой или загрузчиком (bootloader). Поэтому вместо возврата значений точка входа должна, например, вызывать [системную функцию `exit`]. В нашем случае выключение устройства может быть разумным действием, так как больше ничего не остается делать, если исполняемый файл завершает свою работу. На данный момент мы выполняем требование, создавая бесконечный цикл.

[системную функцию `exit`]: https://en.wikipedia.org/wiki/Exit_(system_call)

Если запустить `cargo build` теперь, то мы получим ужасную ошибку _компоновщика_.