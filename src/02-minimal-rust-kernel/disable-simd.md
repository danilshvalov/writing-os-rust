# Отключение SIMD

С помощью инструкций [Single Instruction Multiple Data (SIMD)] процессор может выполнять несколько операций одновременно, что значительно может ускорить работу программы. Архитектура `x86_64` поддерживает различные SIMD-стандарты:

- [MMX]: Набор инструкций _Multi Media Extension_ определяет восемь 64-битный регистров `mm0`, `mm1`, ..., `mm7`. Эти регистры являются всего лишь псевдонимами регистров [для работы с математическими вычислениями][x87]
- [SSE]: Набор инструкций _Streaming SIMD Extensions_, вместо повторного использования регистров для операций с плавающей запятой, добавляет 16 новых регистров: `xmm0`, `xmm1`, ..., `xmm15`.
- [AVX]: _Advanced Vector Extensions_ - это расширения, которые дополнительно увеличивают размер `xmm` регистров. Например, `xmm0` - это нижняя половина `ymm0`. Каждый из них имеет размер 128 бит. Названия соответственно `ymm0`, `ymm1`, ..., `ymm15`.

При использовании SIMD-стандартов производительность программ зачастую увеличивается. Современные компиляторы умеют преобразовывать несложные циклы в SIMD-код с помощью [автоматической векторизации][auto-vectorization].

Однако использование SIMD-регистров в ядре ОС приводит к проблемам с производительностью. При каждом прерывании ядру приходится делать копию всех используемых регистров в память, чтобы потом, когда управление возвращается прерванной программе, привести все регистры в исходное состояние. Если ядро использует регистры SIMD, ему приходится делать копию намного большего объема данных (512-1600 байт), что заметно снижает производительность. Чтобы избежать этой потери производительности, мы хотим отключить функции `sse` и `mmx` (функция `avx` по умолчанию отключена).

Чтобы их отключить, нам нужно добавить в поле `features` название этих функций со знаком минус:

```json
"features": "-mmx,-sse"
```

## Операции с плавающей запятой

К сожалению, `x86_64` архитектура использует SSE-регистры для операций с плавающей запятой. Дело в том, что `core` библиотека Rust использует числа с плавающей запятой (например трейты `f32` и `f64`), поэтому операции с плавающей запятой нам необходимы.

К счастью, LLVM поддерживает функцию `soft-float`, которая эмулирует все операции с плавающей точкой с помощью программных функций, основанных на целых числах. Добавив `soft-float` с знаком плюс, мы включим поддержку вещественных чисел для нашего ядра:

```json
"features": "-mmx,-sse,+soft-float"
```
<!-- links -->
[Single Instruction Multiple Data (SIMD)]: https://ru.wikipedia.org/wiki/SIMD
[x87]: https://ru.wikipedia.org/wiki/X87
[MMX]: https://ru.wikipedia.org/wiki/MMX
[SSE]: https://ru.wikipedia.org/wiki/SSE
[AVX]: https://ru.wikipedia.org/wiki/AVX
[auto-vectorization]: https://wiki2.wiki/wiki/Automatic_vectorization
