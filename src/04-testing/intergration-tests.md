# Интеграционное тестирование

По соглашению все [интеграционные тесты][integration tests] в Rust помещаются в каталог `tests` в корневой папке проекта, т.е. рядом с папкой `src`. Тестовый фреймворк автоматически подхватывает и выполняет все тесты из этой директории.

[integration tests]: https://doc.rust-lang.ru/book/ch11-03-test-organization.html#Интеграционные-тесты

Все интеграционные тесты являются полноценными исполняемыми файлами и полностью отделены от нашего `main.rs`, поэтому каждый тест должен определять свою точку входа. Давайте создадим интеграционный тест `basic_boot`, чтобы разобраться, как это работает:

```rust
// в tests/basic_boot.rs

#![no_std]
#![no_main]
#![feature(custom_test_frameworks)]
#![test_runner(crate::test_runner)]
#![reexport_test_harness_main = "test_main"]

use core::panic::PanicInfo;

#[no_mangle] // отключаем искажение имени этой функции
pub extern "C" fn _start() -> ! {
    test_main();

    loop {}
}

fn test_runner(tests: &[&dyn Fn()]) {
    unimplemented!();
}

#[panic_handler]
fn panic(info: &PanicInfo) -> ! {
    loop {}
}
```

Поскольку интеграционные тесты являются отдельными исполняемыми файлами, нам нужно снова указать все необходимые атрибуты (`no_std`, `no_main`, `test_runner`, и т.д.). Также нам нужно снова создать функцию точки входа `_start`, которая будет вызывает функцию `test_main`. Нам не нужно использовать атрибут `cfg(test)`, потому что интеграционные тесты выполняются только в режиме тестирования.

Мы используем макрос [`unimplemented`], который используется как заглушка. При вызове он всегда вызывает панику. В `panic_handler` мы пока что используем только бесконечный цикл. В идеале, мы бы хотели реализовать эти функции точно также, как и в нашем `main.rs`, используя макрос `serial_println` и функцию `exit_qemu`. Проблема заключается в том, что у нас нет доступа к этим функциям, поскольку тесты никак не связаны с `main.rs`.

[`unimplemented`]: https://doc.rust-lang.org/core/macro.unimplemented.html

Запустив `cargo test` сейчас, вы получите бесконечный цикл, поскольку в итоге вы попадаете в функцию `panic_handler`. Чтобы выйти из QEMU, воспользуйтесь сочетанием клавиш `Ctrl+c`.

Решить эту проблему не трудно: достаточно выделить все необходимые функции в отдельную библиотеку.
